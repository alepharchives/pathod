{"name":"pathod","body":"\r\n__pathod__ is a pathological HTTP/S daemon, useful for testing and torturing\r\nHTTP clients. At __pathod__'s heart is a tiny, terse language for crafting HTTP\r\nresponses. The simplest way to use __pathod__ is to fire up the daemon, and\r\nspecify the response behaviour you want using this language in the request URL.\r\nHere's a minimal example:\r\n\r\n    http://localhost:9999/p/200\r\n\r\nEverything after the \"/p/\" path component is a response specifier - in this\r\ncase just a vanilla 200 OK response. See the docs below to get (much) fancier.\r\nYou can also add anchors to the __pathod__ server that serve a fixed response\r\nwhenever a matching URL is requested:\r\n\r\n    pathod --anchor \"/foo=200\"\r\n\r\nHere, \"/foo\" a regex specifying the anchor path, and the part after the \"=\" is\r\na response specifier.\r\n\r\n__pathod__ also has a nifty built-in web interface, which lets you play with\r\nthe language by previewing responses, exposes activity logs, online help and\r\nvarious other goodies. Try it by visiting the server root:\r\n\r\n    http://localhost:9999\r\n\r\n\r\n\r\nSpecifying Responses\r\n====================\r\n\r\nThe general form of a response is as follows:\r\n    \r\n    code[MESSAGE]:[colon-separated list of features]\r\n\r\nHere's the simplest possible response specification, returning just an HTTP 200\r\nOK message with no headers and no content:\r\n    \r\n    200\r\n\r\nWe can embellish this a bit by specifying an optional custom HTTP response\r\nmessage (if we don't, __pathod__ automatically creates an appropriate one). By\r\ndefault for a 200 response code the message is \"OK\", but we can change it like\r\nthis:\r\n\r\n    200\"YAY\"\r\n\r\nThe quoted string here is an example of a Value Specifier, a syntax that is\r\nused throughout the __pathod__ response specification language. In this case, the\r\nquotes mean we're specifying a literal string, but there are many other fun\r\nthings we can do. For example, we can tell __pathod__ to generate 100k of random\r\nASCII letters instead:\r\n\r\n    200@100k,ascii_letters\r\n\r\nFull documentation on the value specification syntax can be found in the next\r\nsection. \r\n   \r\nFollowing the response code specifier is a colon-separated list of features.\r\nFor instance, this specifies a response with a body consisting of 1 megabyte of\r\nrandom data:\r\n\r\n    200:b@1m\r\n\r\nAnd this is the same response with an ETag header added:\r\n\r\n    200:b@1m:h\"Etag\"=\"foo\"\r\n\r\nBoth the header name and the header value are full value specifiers. Here's the\r\nsame response again, but with a 1k randomly generated header name:\r\n\r\n    200:b@1m:h@1k,ascii_letters=\"foo\"\r\n\r\nA few specific headers have shortcuts, because they're used so often. The\r\nshortcut for the content-type header is \"c\":\r\n\r\n    200:b@1m:c\"text/json\"\r\n\r\nThat's it for the basic response definition. Now we can start mucking with the\r\nresponses to break clients. One common hard-to-test circumstance is hangs or\r\nslow responses. __pathod__ has a pause operator that you can use to define\r\nprecisely when and how long the server should hang. Here, for instance, we hang\r\nfor 120 seconds after sending 50 bytes (counted from the first byte of the HTTP\r\nresponse):\r\n\r\n    200:b@1m:p120,50\r\n\r\nIf that's not long enough, we can tell __pathod__ to hang forever:\r\n\r\n    200:b@1m:p120,f\r\n\r\nOr to send all data, and then hang without disconnecting:\r\n\r\n    200:b@1m:p120,a\r\n\r\nWe can also ask __pathod__ to hang randomly:\r\n\r\n    200:b@1m:pr,a\r\n\r\nThere is a similar mechanism for dropping connections mid-response. So, we can\r\ntell __pathod__ to disconnect after sending 50 bytes:\r\n\r\n    200:b@1m:d50\r\n\r\nOr randomly:\r\n\r\n    200:b@1m:dr\r\n\r\nAll of these features can be combined. Here's a response that pauses twice,\r\nonce at 10 bytes and once at 20, then disconnects at 5000:\r\n\r\n    200:b@1m:p10,10:p20,10:d5000\r\n\r\n\r\nFeatures\r\n========\r\n\r\n#### hKEY=VALUE\r\n\r\nSet a header. Both KEY and VALUE are full _Value Specifiers_. \r\n\r\n\r\n#### bVALUE\r\n\r\nSet the body. VALUE is a _Value Specifier_. When the body is set, __pathod__ will\r\nautomatically set the appropriate Content-Length header.\r\n\r\n\r\n#### cVALUE\r\n\r\nA shortcut for setting the Content-Type header. Equivalent to:\r\n\r\n    h\"Content-Type\"=VALUE\r\n\r\n\r\n#### lVALUE\r\n\r\nA shortcut for setting the Location header. Equivalent to:\r\n\r\n    h\"Content-Type\"=VALUE\r\n\r\n\r\n#### dOFFSET\r\n\r\nDisconnect after OFFSET bytes. The offset can also be \"r\", in which case __pathod__\r\nwill disconnect at a random point in the response.\r\n\r\n\r\n#### pSECONDS,OFFSET\r\n\r\nPause for SECONDS seconds after OFFSET bytes. SECONDS can also be \"f\" to pause\r\nforever. OFFSET can also be \"r\" to generate a random offset, or \"a\" for an\r\noffset just after all data has been sent.\r\n\r\n\r\nValue Specifiers\r\n================\r\n\r\nThere are three different flavours of value specification. \r\n\r\n### Literal\r\n\r\nLiteral values are specified as a quoted strings: \r\n\r\n    \"foo\"\r\n\r\nEither single or double quotes are accepted, and quotes can be escaped with\r\nbackslashes within the string:\r\n\r\n    'fo\\'o'\r\n\r\n\r\n### Files\r\n\r\nYou can load a value from a specified file path. To do so, you have to specify\r\na _staticdir_ option to __pathod__ on the command-line, like so: \r\n\r\n    pathod -d ~/myassets\r\n\r\nAll paths are relative paths under this directory. File loads are indicated by\r\nstarting the value specifier with the left angle bracket:\r\n    \r\n    <my/path\r\n\r\nThe path value can also be a quoted string, with the same syntax as literals:\r\n\r\n    <\"my/path\"\r\n\r\n\r\n### Generated values\r\n\r\nAn @-symbol lead-in specifies that generated data should be used. There are two\r\ncomponents to a generator specification - a size, and a data type. By default\r\n__pathod__ assumes a data type of \"bytes\". \r\n\r\nHere's a value specifier for generating 100 bytes:\r\n    \r\n    @100\r\n\r\nYou can use standard suffixes to indicate larger values. Here, for instance, is\r\na specifier for generating 100 megabytes:\r\n\r\n    @100m\r\n\r\nData is generated and served efficiently - if you really want to send a\r\nterabyte of data to a client, __pathod__ can do it. The supported suffixes are:\r\n\r\n    b = 1024**0 (bytes)\r\n    k = 1024**1 (kilobytes)\r\n    m = 1024**2 (megabytes)\r\n    g = 1024**3 (gigabytes)\r\n    t = 1024**4 (terabytes)\r\n\r\nData types are separated from the size specification by a comma. This\r\nspecification generates 100mb of ASCII:\r\n\r\n    @100m,ascii\r\n\r\nSupported data types are:\r\n\r\n    \r\n    ascii_letters\r\n    ascii_lowercase\r\n    ascii_uppercase\r\n    digits\r\n    hexdigits\r\n    letters\r\n    lowercase\r\n    octdigits\r\n    printable\r\n    punctuation\r\n    uppercase\r\n    whitespace\r\n    ascii\r\n    bytes\r\n\r\n# API\r\n\r\n__pathod__ exposes a simple API, intended to make it possible to drive and\r\ninspect the daemon remotely for use in unit testing and the like. The next\r\nrelease will include a client-side library that makes this transparent.\r\n\r\n### /api/log\r\n\r\nReturns the current log buffer. At the moment the buffer size is 500 entries -\r\nwhen the log grows larger than this, older entries are discarded. The returned\r\ndata is a JSON dictionary, with the form:\r\n    \r\n    {\r\n        'logs': [ ENTRIES ]\r\n    }\r\n\r\nWhere each entry looks like this:\r\n\r\n    {\r\n        # Record of actions taken at specified byte offsets\r\n        'actions': [(200, 'disconnect'), (10, 'pause', 1)],\r\n        # HTTP return code\r\n        'code': 200,\r\n        # Request duration in seconds\r\n        'duration': 0.00020599365234375,\r\n        # ID unique to this invocation of pathod\r\n        'id': 2,\r\n        # The request that triggered the response\r\n        'request': {\r\n            'full_url': 'http://testing:9999/p/200:b@1000:p1,10:d200',\r\n            'headers': {\r\n                'Accept': '*/*',\r\n                'Host': 'localhost:9999',\r\n                'User-Agent': 'curl/7.21.4'\r\n            },\r\n            'host': 'localhost:9999',\r\n            'method': 'POST',\r\n            'path': '/p/200:b@1000:p1,10:d200',\r\n            'protocol': 'http',\r\n            'query': '',\r\n            'remote_address': ('10.0.0.234', 63448),\r\n            'uri': '/p/200:b@1000:p1,10:d200',\r\n            'version': 'HTTP/1.1'\r\n        },\r\n        # The response spec that was served. You can re-parse this to get full\r\n        # details on the response.\r\n        'spec': '200:b@1000:p1,10:d200',\r\n        # Time at which response startd.\r\n        'started': 1335735586.469218\r\n    }\r\n\r\n\r\n\r\n# Installing\r\n\r\n__pathod__ requires Tornado 2.2.1 or later. If you already have __pip__ on your\r\nsystem, installing __pathod__ and its dependencies is dead simple:\r\n    \r\n    pip install pathod\r\n\r\nThe project uses the __pry__ unit testing framework, which you can get here:\r\n\r\n    http://github.com/cortesi/pry\r\n\r\n","tagline":"A pathological HTTP daemon for testing and torturing client software","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}